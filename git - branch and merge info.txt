(Check this youtube video and linked Videos)
https://www.youtube.com/watch?v=oFYyTZwMyAg

https://www.git-tower.com/learn/git/ebook/en/command-line/advanced-topics/merge-conflicts

https://git-scm.com/book/en/v1/Git-Tools-Stashin_

http://jebaird.com/2013/07/08/setting-up-kdiff3-as-the-default-merge-tool-for-git-on-windows.html
https://www.youtube.com/watch?v=-CkqiIPAzgQ

git config --global core.editor "vim"


$ git fetch origin

--	fetch only downloads new data from a remote repository - but it doesn't integrate any of this new data into your working files.
	fetch will never manipulate, destroy, or screw up anything. This means you can never fetch often enough.

$ git pull origin master -- it does 'git fetch' followed by 'git merge'

--	updates current HEAD branch with the latest changes from the remote server. This means that pull not only downloads new data; it also directly integrates it into your current working copy files. 

	This has a couple of consequences:

	1)	Since "git pull" tries to merge remote changes with your local ones, a so-called "merge conflict" can occur.

	2)	It is highly recommended to start a "git pull" only with a clean working copy. This means that you should not have any uncommitted local 	 changes before you pull.

Resolving Merge Conflicts:
--------------------------
	--	if two people changed the same lines in that same file, or if one person decided to delete it while the other person decided to modify 
		it, Git simply cannot know what is correct.


Clone the git project into your local system:

Go to the repository,

http://jebaird.com/2013/07/08/setting-up-kdiff3-as-the-default-merge-tool-for-git-on-windows.html

$cd repository

$ git branch // Lists all the branches in the local repository

/*** Create new Branch and checkit to it

$ (master)git checkout -b ACADPLY-2901  // -b creates the branch and checks to that branch

/*** push the created branch to remote

$ git push origin ACADPLY-2901 // Asks for username and password, Creates branch in remote repository

/**** Make changes in the the local repo, that will be affected to ACADPLY-2901

/*** After the changes add the files to ACADPLY-2901 and commit and push it.

$ (ACADPLY-2901) git add .
$ (ACADPLY-2901) git commit -m "Changes made"
$ (ACADPLY-2901) git push origin ACADPLY-2901 // Pushes files to remote

/*** Create Stable Branch as explained above
$ (master) git checkout -b Stable_PK

/*** Push it
$ (master) git push origin Stable_PK // asks for username and password, creates branch in remote repository

**** If you have 2 working branches and want to merge it and then push it to Stable_PK follow the below steps.

$ git merge --no-ff myfeature 

	- The --no-ff flag causes the merge to always create a new commit object, even if the merge could be performed with a fast-forward. This avoids losing information about the historical existence of a feature branch and groups together all commits that together added the feature

/*** Merge it with another (Say, ACADPLY-2902)
/*** merge the changes from ACADPLY-2902 to ACADPLY-2901

$ (ACADPLY-2901) git merge ACADPLY-2902 

/*** Push the changes to remote ACADPLY-2901 

$(ACADPLY-2901) git push origin ACADPLY-2901

/*** Pull from other branch 
$ (ACADPLY-2901) git pull origin ACADPLY-2902 

/****Finally merge your Stable_PK with updated changes from ACADPLY-2901 (already merged with ACADPLY-2902)
$ (Stable_PK) git merge ACADPLY-2901

/*** Finally push it to Stable_PK
$ (Stable_PK) git push origin Stable_PK


/**** If you have created branches in remote, pull it using
$(master) git pull
	It shows the follwing message
	from https://<The_Link>
		*[new branch] Sample -> origin/Sample
	Already up-to-date

/*** To make it visible in local, first checkout to that branch
$(master) git checkout Sample

$(Sample) git branch 
	** It will now list the new brach pulled from master
	

**** Deleting created branch from remote and local ****

$(master) git push origin :<brach_name>

**NOTE** Though branches are deleted from remote repo, branch are shown in local repo to delete them in local repo use the following

$ (master) git branch -d <brach_name>  
	* -d option deletes the branch
	*NOTE* use -D option if your branch is merged with master or use -d option

----------------------------------------
** Caching your GitHub password in Git 
----------------------------------------

If you're cloning GitHub repositories using HTTPS, you can use a credential helper to tell Git to remember your GitHub username 
and password every time it talks to GitHub.

If you clone GitHub repositories using SSH, then you authenticate using SSH keys instead of a username and password.
 For help setting up an SSH connection, see Generating SSH Keys.

If you prefer working with the command line, you can also install a native Git shell, such as msysgit. 
With msysgit, running the following in the command line will store your credentials:

>	git config --global credential.helper wincred

Remove cached password from git:
---------------------------------

git config --global --unset credential.helper

-------------------------------------------------------------------
Advanced git commands -David Baumgold - Advanced git - PyCon - 2015
-------------------------------------------------------------------

$ (branch) git show  <commit_hash>
	* Shows the information about current commit if no arguments passed to it, if commit hash passed it shows more info about that commmit

$ (branch) git blame <file_name_in_that_branch>
	* For each line of the file, blame will find the last commit to edit the line and commit hash, author,date of commit

// Specify the line range
$ git blame -L 12,22 <file-name> 


----------------------------------------------------------------------------------------------------------------------------
** Cherry-pick -- moving commits to other branches (if the commits are moved to 'master branch' instead of 'feature branch')
----------------------------------------------------------------------------------------------------------------------------

-- git cherry-pick doesn’t alter the existing history within a repository; instead, it adds to the history. As with other Git operations that introduce changes via the process of applying a diff, you may need to resolve conflicts to fully apply the changes from the given commit .

$ (master) git show
	-- copy the commit hash (copy first 6 or 7 chars, it is sufficient to pass it as argument to cherry-pick)

$ (master) git checkout feature

$ (feature) git cherry-pick <commit-hash> 

	* It creates an entirely new commit based off the original commit and its commit message and it doesn't delete the original commit

Once the new commit is created in the 'feature', delete the old commit in 'master' by running

$ (master) git reset --hard HEAD^

	-- HEAD 	== 	The Commit I'm currently sitting on
	-- HEAD^ 	== 	The commit's parent
	-- HEAD^^	==	This commi's grand parent
	-- HEAD~5 	== 	Five commits back from the current commit, it is equivalent to HEAD^^^^^
	
---------
** Rebase 
---------
https://www.atlassian.com/git/tutorials/merging-vs-rebasing/conceptual-overview

-- 	Command for changing the history
-- 	Never change history when other people are working on your branch, unless they know you're doing so
--	Never change history on 'master'
--	Best Practice: Only change the history for commits that have not yet been pushed

eg: 'master' has changed since I started my feature and I want to bring my branch up to date with master

-- rebase finds the merge base, cherry-picks all the commits, and reassings the branch pointer 

$ (feature) git rebase master

 -- It may throw error like commits are diverged and if you try to push it won't allow then force push the commit in the feature
 
 $ (feature) git push -f
 	-- If it shows merge conflicts -> check the status of the branch

 $(feature) git status  -> it shows the conflicts in the 'feature' if any  

 if you are in the middle of rebase and got conflicts, resolve the conflicts manually (conflicts looks similar to merge conflicts, resolving merge conflicts creates new commit, while rebase is not), or you can cherry-pick to resolve conflicts, then run

 $ (feature) git rebase --continue

 if you want to rebase later and fix the conflict later, run

 $ (feature) git rabase --abort

--------
** reflog - it shows commits in order of when you lasted referenced them
--------

If you are changing the history reflog is best command

$ git checkout <hash> 

$(feature) git reset --hard <commit-hash> to reset the branch pointer to the commit

------------------------
Squashing and Splitting
------------------------
-- If you have forgotten to add files to this commit then

$ (feature) git add missed-file.txt
$ (feature) git commit --amend 
	-- Makes a new commit with new file added, and replaces the most recent commit with new one. 

If you want to squash more commits to one commit then use,

$(feature) git rebase --interactive HEAD~5 
	-- It opens the editor with last five commits showing the action to be performed on them, rename action 'pick' to 'squash' on the commits. 
		(press 'i' in the keyboard  to edit the file in the editor and to save and quit the editor, press 'escape' button to come out of editing mode to normal mode then type :wq -> this commands will saves the file and quits the editor -- This editor behaves more like vi/vim editor in Linux)
	-- Close the editor and it asks for new commit message, enter some message and save and quit the editor.

-- Squashing commits changes history

--	Change the actions 'pick' from 'squash' for all the commits you wanted to squash them in to one

** Splitting commits into small commits

$ (feature) git rebase -i HEAD~3  -> git will pause in the rebase process to create new commits

	-- Change 'pick' to 'edit' for the commit to make changes to save and quit the editor,

Then pop off the commit using,

$ (feature) git reset HEAD^  -- Don't use --hard option it may change the commit
 
 	-- files added in that commit are in staged area and check with the command

$ (feature) git status - will show all the files in its parent commit.

If that commit contains more files then you can add one file and commit individually.

$ (feature) git add <file1>
$ (feature) git commit -m "Sample"

$ (feature) git rebase --continue

Skipped 'bisect' command which tells which commit broke the build.


Squash commits into one:
---------------------------
$ git rebase -i HEAD~5 (or you can get commit hash till which commit you want to rebase with), to see the commits, run $git log
 <select commits to squash and enter commit message>

once done force-push your changes to remote branch:

$ git push -f origin <feature-branch>



Cherry-picking a commit on build or target branch:
--------------------------------------------------

$ git fetch origin build

$ git reset --hard origin/build

$ git cherry-pick "commit-hash" 

get commit hash from the target branch

if any conflicts, resolve manually and add them to index and continue the cherry-pick using,

$ git cherry-pick --continue

once done push changes to remote branch

$ git push origin <build>


To remove the commit:
----------------------

$ git rebase -i HEAD~2

Replace pick with drop before commit hash.

(if any conflicts resolve them and continue the rebase) 

Publish the changes forcefully,

$ git push -f origin <branch_name>


Creating pull request to dev:
-----------------------------

-- 	pull the changes from dev to local - $(dev) git pull origin dev

--	Go to your branch, rebase dev over your branch, make sure your commit in your feature branch are squashed into one commit and pushed to 
	remote before rebasing dev to your branch
	
	--	$(feature) git rebase dev

		if you get any conflicts resolve and continue the rebase, then force push the changes to your branch
		$(feature) git push -f origin feature

-- Once changes pushed, go to repo in the github, create pull request and get atleast 2 +1's


Edit an incorrect commit message:
---------------------------------

$ git commit --amend -m "YOUR-NEW-COMMIT-MESSAGE"

In case you’ve already pushed your commit to the remote branch then you need to force push the commit with this command:

$ git push <remote> <branch> --force or $ git push -f origin <branch>

To delete a remote branch:
--------------------------

$ git push origin --delete <branchName>


Rename git branch locally and remotely:
---------------------------------------

$ git branch -m old_branch new_branch         # Rename branch locally    
$ git push origin :old_branch                 # Delete the old branch    
$ git push --set-upstream origin new_branch # Push the new branch, set local branch to track the new remote


Deleting a remote tag:
----------------------

$ git tag -d <12345>

$ git push origin :refs/tags/<12345>

// git advanced merge:

-- Ignoring the spaces 
$ git merge -Xignore-space-change <branch-to-be-merged>

-Xignore-all-space -> ignores all the spaces

$ git show :1:hello.rb > hello.common.rb
$ git show :2:hello.rb > hello.ours.rb
$ git show :3:hello.rb > hello.theirs.rb

Stage 1 is the common ancestor, stage 2 is your version and stage 3 is from the MERGE_HEAD


Un-applying a Stash:
--------------------
You can reapply the one you just stashed by using the command shown in the help output of the original stash command:

$ git stash apply

If you want to apply one of the older stashes, you can specify it by naming it, like this: 

$ git stash apply stash@{2}

In some use case scenarios you might want to apply stashed changes, do some work, but then un-apply those changes that originally came from the stash. Git does not provide such a stash unapply command, but it is possible to achieve the effect by simply retrieving the patch associated with a stash and applying it in reverse:

$ git stash show -p stash@{0} | git apply -R

Again, if you don’t specify a stash, Git assumes the most recent stash:

$ git stash show -p | git apply -R


->	You may want to create an alias and effectively add a stash-unapply command to your Git. For example:

$ git config --global alias.stash-unapply '!git stash show -p | git apply -R'

$ git stash apply

$ git stash-unapply


Kdiff3
-----

$ git config --global merge.tool kdiff3

$git config --global mergetool.kdiff3.cmd '"C:\\Program Files (x86)\\KDiff3\\kdiff3" $BASE $LOCAL $REMOTE -o $MERGED'

A useful git command if you want to see the last committer on a branch. Helps if you want to clean up branches from your team in a large repos:
git for-each-ref --format="%(align:30,left)%(color:yellow)%(authorname)%(end) %(align:30,left)%(color:red)%(refname:strip=3)%(end)" --sort=authorname refs/remotes'