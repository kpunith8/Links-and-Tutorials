----------------------------------
JavaScript objects and properties:
----------------------------------

> Define a property of an object:

		var cat = {
			name: {first: 'Fluffy', last: 'LaBeouf'},
			color: 'White'
		};

		Object.defineProperty(cat, 'fullName', {
			get: function() {
				return this.name.first + ' ' + this.name.last;
			},
			set: function(value) {
				var nameParts = value.split(' ');
				this.name.first = nameParts[0];
				this.name.last = nameParts[1];
			}
		});

		Usage of getter and setter:

		cat.fullName = 'Muffin Top';
		display(cat.fullName);
		display(cat.name.first);

>	Prototypes:

		Defining prototype to get the last element of an array:

		var arr = ['red', 'blue', 'green'];

		var last = arr.last // given undefined because last property is not defined on JavaScript array, it can be added as follows,

		Object.defineProperty(arr, 'last', { // Defines last property on arr object, if you want to do it on Array object, replace arr with 'Array.prototype'
		get: function() {
				return this[this.length-1];
			}
		});

		var myFunc = function() {}; display(myFunc.prototype); returns an empty {}
		var cat = {name: 'abc'}; display(cat); returns undefined, it has no prototype, it has __proto__ property, accessed using object.__proto__

		A Funtion's prototype: is the object 'instance' that will become the prototype for all objects created using this function as a constructor.
		An Object's prototype: is the object instance from which the object is inherited.

		function Cat(name, color) {
			this.name = name;
			this.color = color;
		}

		Cat.prototype.age = 3, will add age prototype to cat function (Can also be created as, Cat.prototype = {age: 5};)

		var fluffy = new Cat('Fluffy', 'White');
		var muffin = new Cat('Muffin', 'Brown');

		display(fluffy.age); display(muffin.age); // will display age '4'

		fluffy.age = 5; // it adds new property to fluffy object and display(fluffy.age) displays '5'
		and fluffy.__proto__.age will still display '4' since it's a prototype not an property

	> Creating prototype chains:

		Function Animal(voice) {
			this.voice = voice || 'grunt';
		}
		// Making all the animals make sound
		Animal.prototype.speak = function() {
			display(this.voice);
		}

		// Adding animal prototype to Cat
		Cat.prototype = Object.create(Animal.prototype);

		fluffy.speak(); will display 'Grunt'

		It can be called from Cat function as,
		function Cat(name, color) {
			Animal.call(this, 'Meow');
			this.name = name;
			this.color = color;
		}

		this will make Cat object as Animal and if you want it as Cat instance,
		Cat.prototype.constructor = Cat

		fluffy.__proto__ -> returns Cat; and fluffy.__proto__.__proto__-> returns Animal

	> Creating prototypes with classes:

		Class Animal {
			constructor(voice) {
				this.voice = voice || 'Grunt';
			}

			speak() = {
				display(this.voice);
			}
		}

		Class Cat extends Animal {
			constructor(name, color) {
				super('Meow');
				this.name = name;
				this.color = color;
			}
		}

-------
JQuery
-------

>	Load JQuery from CDN if it fails add the script tag as follows,
		<script>
			window.JQuery || document.write('<script src="jquery.js"><\/script>')
		</script>

>	Selectors:

		$('a[title="Programming"]') // selects <a> elememts that have a title attribute with the specified value
		or
		$('a[title]') // selects <a> elememts that have a title attribute

		$(':input') // selects all input elements, including button, select, textares, button, images, radio and more
		$(':input[type="radio"]') // Selects all radio buttons on the page, and
		$('input') selects only selects input fields

		$('input[value^="sample"]') // Selects any input element whose value attribute begins with "sample" (Case sensitive), use $ to find ends with
		and use * to find a word contains.

		$('div:contains("my div")')

		$('div:eq(0)') Finds the first div

>	Interaction with DOM:

		Iterating through nodes:

			$('div').each(function(index) {
				$(this).text(); // need to wrap JQuery object to this element
			});

			or

			$('div').each(function(index, element) {
				$(element).text(); // No need to wrap JQuery object, element refers to this
			});

>	Appending or removing nodes:

		$('<span>(office)</span>').appendTo('.officePhone'); (or)

		$('.officePhone').append('<span>(office)</span>');

		prepend will add it to the begining of the elements

		wrap() - Wrapping elements

		<div class="state">Arizona</div>

		$('.state').wrap('<div class="US_State"/>'); this will results in

			<div class="US_State">
				<div class="state">Arizona</div>
			</div>

		.remove() is used to remove the nodes.

		addClass(), removeClass(), toggleClass()

>	Handling Events: Identifying event type, event.type -> returns a string

		Multiple events and handlers can be defined in on() using a map:

		$('#MyTable tr').on({
			mouseenter: function() {
				$(this).addClass('mouseEnter');
			},
			mouseleave: function() {
				$(this).removeClass('mouseEnter');
			},
			mouseover: function() {
				// Any other action
			}
		});

		hover(moseenter, mouseleave);

		toggle() // toggels through functions defined within

>	Ajax in jQuery

		$.get() and $.post() : gets raw data from the server
		$(selector).load() : Loads html data from the sever
		$.getJSON() : get/post and return JSON
		$.ajax() : core functionality

		jQuery ajax functions work with REST APIs and web services

		$('#myDiv').load('../sample.html #myID'); // Which loads only #myID content from the sample.html

		$.get(url, data, callback, datatype);

		$.get('sample.html', function(data){
			$('#outputDiv').html(data);
		});

------------------------------------------------
* Building a JavaScript Environment: Cory House |
------------------------------------------------

# ember - fully opioniated library

# Editor Selection:

	VSCode - JavaScript editor, other options - atom

	EditorConfig - helps create a config for a editor

		Install the plugin before using in VS code, goto, editorconfig.org -> download the plugin -> copy the command and open VS code, 'Ctrl + SHift + p' to open the command pallate and paste the command and select to install

		Create .editorconfig file in the project root.

# Package managers:

	Use 'node security platform' to check for package vulnerabilities, install it using,

	$ npm instal --global nsp

	Run this to check, using,

	$ nsp check

 Dev servers:

	http-server : Ultra-simple, single command serves current directory
	live-server
	express, koa, hafi
	budo
	webpack-server : hot reloading, serves from memory
	browserSync : dedicated IP for sharing on LAN, all interactions remains in sync, great for cross device testing, integrates with webpack, gulp, browserify

	Consider: express

# Sharing work-in-progress:

	- localtunnel : share in local machine, install using npm, start the app then run using,

		usage: $ lt --port 3000

	- ngrok : secure tunnel to local machine, install ngrok, install authtoken, start the app

		usage: $ ./ngrok http 80

	  now : install, create the start script,

		usage: $ now

	- surge : Quickly host static files to public URL, install

		usage: $ surge

	- Consider: localtunnel; usage: $ lt --port 3000

		Add, --subdomain option to include custom subdomain in the url; usage: $ lt -port 3000 --subdomain punith // Will give link as follows, https://punith.localtunnel.me

> Automation:

	grunt

gulp : in memory streams, code over configuration,

	- npm scripts : declared in scripts section of the package.json, can leverage your OS command line, call separate node scripts, Convention based pre/post hooks, simpler debugging, no need for separate plugins

	- add rules to scripts section in package.json

	- packages used in scripts sections are not required to be installed globally.

		"scripts": {
		    "prestart": "node ./startMessage.js",
		    "start": "node ./index.js",
		    "security-check": "nsp check",
		    "share": "lt --port 3000 --subdomain punith"
	  	},

  - Run user-defined scripts as follows,

  		$ npm run security-check

  - Running concurrent tasks,

  	"scripts": {
	    "prestart": "node ./startMessage.js",
	    "start": "npm-run-all --parallel security-check open-source",
	    "open-source": "node ./index.js",
	    "security-check": "nsp check",
	    "localtunnel": "lt --port 3000 --subdomain punith",
	    "share": "npm-run-all --parallel open-source localtunnel"
  	},

  - To silence the noise created in the command line, use

  		$ npm start -s // option to reduce the noise

# Transpilling:

	- TypeScript : Enhanced autocomplete, readability, safer refactoring, additional non-standard features.

	- Elm : compiles down to js, clean syntax, immutable data structures, friendly erros, all errors are compile-time erros, interops with JS -> Deep learing curve required to adopt this

	- Babel : write standardized JS, leverage full JS eco system, use experimental features earlier, no type defs, annotations required, test, lint, great libs, safety, ES6 imports are statically analyzable

		it offers two ways to configure:

		package.json : place it in a section called "babel" : { },

		.babelrc : Recommended - keep it in project root folder, not npm specific

		- compile using $ babel-node <file-name.js>

# Bundling:

	- To bundle the JavaScript that the browsers can understand

	- webpack - import css, images etc like JS, built-in hot reloading web server, bundle splitting

	- webpack.config.js file in the root folder required.

	- To use it in node.js app, add the following,

		import webpack from 'webpack';
		import config from './webpack.config';

		const compiler = webpack(config);

		// Required to run webpack in express
		app.use(require('webpack-dev-middleware')(compiler, {
		    publicPath: config.output.publicPath
		}));


# Linting:

	- Enforces consistency - curly brace position, confirm/alert boxes in production code, trailing commas, declaring global variables, disallowing the usage of eval (potentially risky to use)

	- Avoids mistakes - Extra paranthesis, overwritng a function, assignment in conditional, missing default case in switch, leaving debugger/console.log statements

	- If any of this violated can fail the build while developing and deploying the code in production

	- Linters to consider: JSLint, JS Hint, ES Lint

	- Consider ES Lint - TS Lint supports the type script (consider if working on Type script)

	- Can be configured in package.json or create .eslintrc.json file in the project root folder

	- eslintConfig section can be added in package.json

	- @ github.com/dustinspecker/awesome-eslint - to get the available plugins for different JavaScript frameworks

	- Use a preset - ES lint recommended list or start from scrath which fits the team standards or airbnb, standardjs presets

	# Downsides:

		- ESLint doesn't watch files, To watch files use (Upon save)

			- eslint-loader (if using webpack) - re-lints all files upon save
			- eslint-watch - ESLint wrapper that adds the file watch - not tied to webpack, better warning/error formatting, displays clean message, easily lint tests and build scripts

		- Doesn't support experimental JavaScript features, to use experimental features use,

			- babel-eslint

	# Need eslint, eslint-watch, eslint-plugin-import plugins to make it work.

	- create a script in package.json as,

		"lint": "esw webpack.config.* src --color" // esw; eslist-watch executable which looks for config file and in src folder, folders can be specified by leaving a space

		run it as; $ npm run lint

	- To disable a lint in a file, use the following comment in file,

		/* eslint-disable no-console */

	- To disable in lint in a line, use the follwing in the line,

		// eslint-disable-line no-console

	- To watch the files use the following,

		 "lint:watch": "npm run lint -- --watch" -> run it as; $ npm run lint:watch, add the lint:watch to start script of npm

# Testing and Continuous integration:

	- Testing Framework:

		mocha, jasmine (has assertion library built in), Tape (Minimal configuration), AVA (runs impacted unit tests, new), Jest (from facebook - popular for react developers - wrapper over Jasmine) - Consider -> Mocha

	- Assertion Library: Mocha doesn't have assertion library built

		chai.js, should.js, expect.js - Consider -> chai.js

	- Helper Library:

		JSDOM - simulate the browser's dom - can run DOM related tests, without a browser
		cheerio - jQuery for the server, Query virtual DOM using jQuery selectors

	- Where to run tests:

		Browser: karma, Testem
		Headless Browsers: PhantomJS - has no visible interface
		In memory DOM: JSDOM - 9.8.0 used in the project

	- mocha + chai + jsdom(9.8.0)

		add this in scripts section of package.json

		"test": "mocha --reporter progress src/testSetup.js \"src/**/*.test.js\""

# Continuous integration:

	- travis: Linux based
	- appveyor: window based
	- Jenkins
	- circleCI
	- Semaphore
	- snapCI

	- travis

# HTTP Calls:

	- Node: http, request
	- Browser: XMLHttpRequest(xhr), jQuery, Fetch
	- Node and Browser: isomorphic-fetch, xhr, SuperAgent, Axios

	Demo: Fetch

	- Mocking HTTP:

		Nock - to mock http calls
		Static JSON
		Create developement server: api-mock, JSON server, JSON schema faker (To use dynamic data)

	- Declare schema: JSON Schema Faker
	- Generate random data: faker.js, chance.js, randexp.js
	- Serve data via API:  JSON Server

# Production build:

	- Minification: Speeding page loads, saving bandwidth
		- Shortens variable names and funciton names, removes comments, removes white spaces and new lines
		- tree shaking / dead code elimination (webpack does this)

----------------------------------
* ES6: Fundamentals: mark-zamoyta:
-----------------------------------
> Check the broweser compatability list for ES6 - http://kangax.github.io/

> let and const have block scoping

> Invoking the function with in function

	var invoice = {
		number: 123,
		process: function() {
			return () => console.log(this.number);
		}
	};

	invoice.process()(); - returns 123

> It is not allowed to bind new object to the arrow function or call or apply methods on new object

> putting arrow symbol on next line throws, Syntax error: 'unexpected token =>'

	for ex: var getPrice = ()
						=> 100;

> Default Function Parameters:
	var sample = function(product = 100, type='software') {}

	passing product as undefined sets default value 100

	var getTotal = function(price, tax= price * 0.75) { // accepts price passed to the function to compute tax, function or variables in the context can be
		// passed to the function for ex: tax = price * getTax()
		console.log(tax);
	}

> Spread and Rest Operator (...) - array manipulation:

	... used as rest symbol before the argument, for ex, var sample = function(price, ...categories) {}; and can be used as, sample(1, 'software', 'hardware');

	... also used as spread operator, it accepts the array and splits into list of params

	..."45678" -> will be spread into 4,5,6,7, and 8 individual character

> Object Literal Extensions:

	var price = 5.99, quantity = 10;

	var productView = {
		price,
		quantity,
		calculateValue() { // Passing function name as string is allowed for ex: "calculate value" () -> Can be accessed using, productView["calucalate value"]()
			return this.price * this.quantity // No longer requires funciton keyword
		}
	};

	It returns object as follows, { price: 5.99, quantity: 10 } - it doesnot require ':' to be spcified to set the value to the object

> for ... of Loops - Loops through elements of an array and characters of a string

	ex: for (var item of categories) { // categories = [,,]; -> returns 'undefined undefined'; since elements with in array ends with comma in JavaScript
		console.log(item);
	}

> Octal and Binary Literals:

	Use '0o10' or '0O10' - for octals and '0b10' or '0B10' - for binaries

> Template Literals:

	let number = '1350';
	console.log(`Number is: ${number}`); // Allows to write content into multiple lines without \n and maintains tabs and newlines
	console.log(`Number is: ${"INV-" + number}`); // returns INV-1350, expressions are allowed within the { }

	interpolation takes place first before the function calls

	Tagged function literals - ex: processInvoice `template`; // processInvoice is a function with one parameter
	let invoiceNumber = '1350';
	let amount = '2000';

	processInvoice `Invoice: ${invoiceNumber} for ${amount}`;

	processInvoice(segments, ...values) {
		console.log(segments); // returns ["invoice: ", " for ", ""]
		console.log(values); // returns [1350, 2000]
	}

> Destructuring: arrays and objects:

	ex:
		let salary = ['32', '50', '75'];
		let [low, average, high] = salary; // skip the elements by specifying , between elements for ex: [low, , high] -
																			 // second elemnts is not assigned to any variable

		console.log(average); // returns 50

	Objects can be assigned to another name as follows, {high: newHigh, average:newAvg} = salary; where salary = {high: 25, average: 20};

> Classes and Modules:

	Modules, variables and functions can be exported

	importing statements are hoisted to top

	export let moduleId = 99; which can be imported as id as follows, import { moduleId as id } from 'module.js'; // If we try to aceess
	// moduleId throws runtime error: moduleId is undefined

	We can also import default module names as alias using, import { default as myProjectName } from 'module.js';

	We can also export { projectId as default, projectName }; when imported projectId is imported as default.

	Classes are not hoisted

> New types and Object Extensions:
	- Symbols:

		It is unique identifier, and not visible while inspecting an elements, and used for debugging purposes.
		can be constructed using,
		let eventSymbol = Symbol('resize-event');

		Symbol.for('event'); -- Returns the symbol registered with event, creates one if not exist
		Symbols can be used as property of an object and can be declared within [],
		for ex:
			let article = {
				title: 'Title',
				[Symbol.for('article')]: 'My Article'
			};

			and can be accessed as, article[Symbol.for('article')]; - returns 'My Article'

		Object.getOwnPropertySymbols(article); -> returns symbols in a article object as follows, [Symbol(article)]

	- Well-known symbols;

		Symbol.toStringTag is a well-known symbol
		Blog.prototype[Symbol.toStringTag] = 'Blog Class';
		let blog = new Blog();
		console.log(blog.toString()); -- returns [object Blog Class] // This is an example of meta-programming

	> Object Extensions:

		Object.setPrototypeOf(a, b); -- adds all the props of b to a

		Object.assign(target, a, b); -- here target is an empty object, paramenters of a and b are populated to target object
			If both a and b have the same property then b`s property overloads the a`s property.
			for ex: a = { a: 1}; b = { a: 5, b: 6 }; c = { c: 10 };
				let target = {};
				Object.assign(target, a, b); -- target returns, { a: 5, b: 6 }

				Object.defineProperty(b, 'c', {
					value: 10,
					enumerable: false // Properties are enumerable by default
				});

				Object.assign(target, a, b); -- target has,  { a: 5, b: 6 } because of enumerable set to false

				Object.setPrototypeOf(b, c);
				Object.assign(target, a, b); -- returns,  { a: 5, b: 6 } - assign will not look through prototype chain

		Object.is(object, object); -- compares two objects,
		Object.is(amount, total); -- returns false, here amount = 0, total = -0; in javascirpt these two are equal

	> String extensions:

		Add unicode strings within a string as, \u{1f3c4} - astral plane values (1f3c4 returns surfer emoji)

		String.fromCodePoint(0x1f3c4); -- Gives surfer emoji

		String.raw`${title} \u{1f3c4}\n`; -- returns interpolated text for title and does not process other characters, it returns raw text

		string.repeat(10); -- repeats the string specified number of timers

	> Number Extensions:

		Number.isInteger(), Number.parseInt(), Number.isSafeInteger(), and so on..
		Number.EPSILON, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER - constants

	> Math Extensions:

		Math.sign(0);
		Math.cbrt(22);

	> RegExp Extensions:

		pattern = /900/yg;
		pattern.lastIndex - last index can be set using y flag, pattern.flags - returns the flags set to the pattern (gimuy are the different flags passed to the pattern)

> Iterators, Generators, and Promises:

	> Iterators:

		let ids = [9000, 9001, 9002];
		let id = ids[Symbol.iterator](); -- ids[Symbol.iterator] returns function
		it.next(); -- returns {done: false, value: 9000}

	> Generators: yields

		function *process() { // It does not exist in the function stack, we need iterators to call generators mulitple times, * says its a generator
			yield 8000;
			yield 8001;
		}

		let it = process();
		it.next(); -> next() kicks off the generator and then can be passed a value to next as parameter and generator yields, let result = yield;
		yield also can be used in arrays as follows, let arr = [yield, yield, yield]; and can be set by using it.next() as it.next(1); it.next(100);

		yield has low precedence; array can also be yielded, yield [1,2,3]; - entire array is yielded when iterated,
		To yield the each array items with in a array use, yield* [1,2,3]; -- it yields 1, 2, 3 as seperate yields, yield* is known as 'iterator delegation'.

		* it.throw('foo'); it can be called on generators, it cathces the error and terminates the iterator (Generator should have try catch logic)
		if no try catch specified, it.throw('foo'); throws exception: foo on iterating through yield.
		for ex:
			function *process() {
				yield 900;
				yield 901;
				yield 902;
			}

			let it = process();
			it.next(); -- returns 900
			it.throw('foo'); -- returns Exception: foo
			it.next(); -- returns (execution terminates )

		* it.return('foo'); -- returns {value: "foo", done: true}, calling it.next(); -- returns {value: undefined, done: true} though generator has yield

> Promises: is an object waiting for an async action to complete

	function doAsync() {
		let p = new Promise(function(resolve, reject) {
			setTimeout(function() {
				resolve();
			}, 2000);
		});

		return p;
	}

	use, 'then' function on promise to reject and resolve the promise,
	doAsync().then(function(value) {
		console.log('fulfilled...');
	},
	function(reason) {
		console.log('rejected...');
	});

	then function can be chained, we can also call 'catch' function on promise
	doAsync.catch(function(reason) {
		console.log(reason);
	});

	Promise.all([p1, p2]).then(...); -- It accepts two promises, completes both
	Promise.race([p1, p2]).then(...); -- First completed promise is returned

> Arrays and Collections:

	> Array Extensions:

		Array.of(9000); - has only one item in ES6, but in ES5 creating array like, Array(1000) - leads to array of size 1000
		Array.from(array, v => v + 100);
		array.fill(900, startIndex(inclusive), endIndex(exclusive)); - fills each element of array with 900 (replaces the existing element in the array), specifying index will start from that index
		array.find(value => value > 50); - it won't scan the whole array, returns the first occurance matching the condition
		array.findIndex(function(value, index, array) {
			return value === this;
		}, 700);
		array.copyWithin(copyToIndex, copyFromIndex);
		...array.entries(); - returns [0, item1], [1, item2] ...
		...array.keys(); - returns index value of an array 0 1 2 ...
		...array.values(); - returns the values of an array1

	> Array Buffer and Typed Array:

		Array Buffer is an array of 8 bit bytes
		new ArrayBuffer(1024); - buffer.byteLength - returns 1024

	> Map and WeekMap:

		let emp = { name: 'Jake' };
		let emp1 = { name: 'Janet'};

		let employees = new Map();
		employees.set(emp, 'ABC');
		employees.set(emp1, 'CDE');

		employees.get(emp); -> returns ABC, .delete(obj) - to delete, .length to get the length of the map, .clear() - clears the map, .entries()
		let arr = [
			[emp, 'ABC'],
			[emp1, 'CDE']
		];
		let employees = new Map(arr); -> it accepts array of objects as well

		.has(obj); -- returns boolean if obj exists

		[...employess.values()]; -> returns all the values in the map

		let emp = new WeakMap(); -> it is not possiblr to call .length property on weakmap because object references are garbage collected.

	> Set and WeakSet: Unique values exist in the collection

		let perks = new Set(); -- it accepts array an an argument to create the set
		set.add('Car');
		set.add('Vacation');

		perks.size; -> returns 2

		perks.has('Car'); -- returns boolean if value exists keys(), values(), entries() supported in set

	> Subclassing: extending the existing Objects in JS - It helps add user defined functions

		class Perks extends Array {
		}

		let a = Perks.from([5, 10, 15]); - method from is taken from Array

> The Reflect API: DSL - Domain Specific Language

	Object Construction and method calls - Reflect is an Object
	Reflect.construct(target, argumentList[, newTarget]);

	Reflect.construct(Resturant, ['abc', cde]); -- arguments should be passed as an array

	Reflect.apply(Resturant.prototype.show, {id: 99});

	Reflect.getPrototypeOf(Resturant);
	Reflect.setPrototypeOf(r, setup); -- sets the property setup to r

	Reflect.get(r, 'id'); - gets the id from r
	Reflect.set(r, 'id', 100, alt); - sets the id on r, alt is new object and assign the 100 to id prop in alt object
	Reflect.has(r, 'id'); - true if the property exists
	Reflect.ownKeys(r); - array of properties in the r
	Reflect.defineProperty(r, 'id', {value: 100, enumerable: true});
	Reflect.deleteProperty(r, 'id');
	Reflect.getOwnPropertyDescriptor(r, 'id'); - -- Returns descriptor object, which contains, configurable, enumerable, writable and value property with values

	Reflect.preventExtensions(target); -- prevents adding new property to target object
	Reflect.isExtensible(target); -- to check whether target is extensible

> The Proxi API: its an object wraps an another object - used for security in the application, use it for profiling

	var p = new Proxt(employeeObject, {
		get: function(target, prop, reciever) {
			 if(prop === 'salary') return 'denied';
				 return Reflect.get(target, prop, reciever);
		}
	});

	p.salary -- returns

	var p = new Proxt(getIdProperty, {
		apply: function(target, prop, reciever) {
			return Reflect.apply(target, prop, reciever);
		}
	});

## Asynchronous JS:
```javascript
window.onload = function() {
	var http = XMLHttpRequest();

	http.onreadystatechange = function() {
		if (http.readyState === 4 && http.status === 200) {
				console.log(JSON.parse(http.response)); // JSON.parse converts to JavaScript object
		}
	};

	http.open('GET', 'data/source.json', true); // true for asyn calls
	http.send();
};
```

## Regular expressions: https://regex101.com/

- `/text/gi` - `g` specifies all matches in the file or object, `i` specifies for case insensitive.

- `/[ti]ext/g` - matches `t` or `i` as first character in the text.

- `/[^aeiou]man/g` - excludes `a or e or i or o or u` from the first character being matched.

- `/[a-zA-Z]man/g` - first character can be any character and can be case insensitive. It can be any range a-f, k-q and can be number
	range as well 0-9, 1-6; To make the whole sentence case insensitive add `i` flag to it or it applies to first character.

- `/[0-9]+/g` - matches at between one and unlimited numbers for ex: 123030330030003.....

- `/[0-9]{11}/g` - matches exact 11 numbers.

- `/[0-9]{11, 15}/g` - matches between 11 to 15(inclusive) numbers.

- `/[0-9]{5, }/g` - Matches at least 5 and any number, not less than 5.

- `\d` - matches any digit, `\w` - matches any word character (a-z, A-Z, 0-9, and _'s),
	`\s` - match a white space, `\t` - matches only tabs

- `/\d{3}\w{10}` - matches 3 digits followed by 10 word characters.

- `+` - at lease one or more

- `?` - zero-or-one qualifier (makes a preceding char optional)

- `.` - any character whatsoever (except new line character)

- `*` - zero-or-more qualifier

- `^[a-z]{5}$` - it takes only 5 characters, in the beginning and ending with 5 characters, doesn't matches anything else
	ex: `abcde` - matched not the `abc` or  `abdjdkjdjd`

	`[a-z]{5}$` - matches 5 characters at the end
-
