# List of JavaScript Libraires to consider:

	lodash, ember, expressjs, 

----------------------------------
JavaScript objects and properties:
----------------------------------

> 	Define a property of an object:

		var cat = {
			name: {first: 'Fluffy', last: 'LaBeouf'},
			color: 'White'
		};

		Object.defineProperty(cat, 'fullName', {
			get: function() {
				return this.name.first + ' ' + this.name.last;
			},
			set: function(value) {
				var nameParts = value.split(' ');
				this.name.first = nameParts[0];
				this.name.last = nameParts[1];
			}
		});

		Usage of getter and setter:

		cat.fullName = 'Muffin Top';
		display(cat.fullName);
		display(cat.name.first);

>	Prototypes:

		Defining prototype to get the last element of an array:
		
		var arr = ['red', 'blue', 'green'];

		var last = arr.last // given undefined because last property is not defined on JavaScript array, it can be added as follows,

		Object.defineProperty(arr, 'last', { // Defines last property on arr object, if you want to do it on Array object, replace arr with 'Array.prototype'
		get: function() {
				return this[this.length-1];
			}
		});

		var myFunc = function() {}; display(myFunc.prototype); returns an empty {}
		var cat = {name: 'abc'}; display(cat); returns undefined, it has no prototype, it has __proto__ property, accessed using object.__proto__

		A Funtion's prototype: is the object 'instance' that will become the prototype for all objects created using this function as a constructor.
		An Object's prototype: is the object instance from which the object is inherited.

		function Cat(name, color) {
			this.name = name;
			this.color = color;
		}

		Cat.prototype.age = 3, will add age prototype to cat function (Can also be created as, Cat.prototype = {age: 5};)

		var fluffy = new Cat('Fluffy', 'White');
		var muffin = new Cat('Muffin', 'Brown');

		display(fluffy.age); display(muffin.age); // will display age '4' 

		fluffy.age = 5; // it adds new property to fluffy object and display(fluffy.age) displays '5' 
		and fluffy.__proto__.age will still display '4' since it's a prototype not an property

	> Creating prototype chains:

		Function Animal(voice) {
			this.voice = voice || 'grunt';
		}
		// Making all the animals make sound
		Animal.prototype.speak = function() {
			display(this.voice);
		}

		// Adding animal prototype to Cat
		Cat.prototype = Object.create(Animal.prototype);

		fluffy.speak(); will display 'Grunt'

		It can be called from Cat function as,
		function Cat(name, color) {
			Animal.call(this, 'Meow');
			this.name = name;
			this.color = color;
		}

		this will make Cat object as Animal and if you want it as Cat instance,
		Cat.prototype.constructor = Cat

		fluffy.__proto__ -> returns Cat; and fluffy.__proto__.__proto__-> returns Animal

	> Creating prototypes with classes:

		Class Animal {
			constructor(voice) {
				this.voice = voice || 'Grunt';
			}

			speak() = {
				display(this.voice);
			} 
		}

		Class Cat extends Animal {
			constructor(name, color) {
				super('Meow');
				this.name = name;
				this.color = color;
			}
		}

-------
JQuery
-------

>	Load JQuery from CDN if it fails add the script tag as follows,
		<script>
			window.JQuery || document.write('<script src="jquery.js"><\/script>')
		</script>

>	Selectors:

		$('a[title="Programming"]') // selects <a> elememts that have a title attribute with the specified value
		or
		$('a[title]') // selects <a> elememts that have a title attribute

		$(':input') // selects all input elements, including button, select, textares, button, images, radio and more
		$(':input[type="radio"]') // Selects all radio buttons on the page, and 
		$('input') selects only selects input fields

		$('input[value^="sample"]') // Selects any input element whose value attribute begins with "sample" (Case sensitive), use $ to find ends with
		and use * to find a word contains.

		$('div:contains("my div")')

		$('div:eq(0)') Finds the first div

>	Interaction with DOM:

		Iterating through nodes:

			$('div').each(function(index) {
				$(this).text(); // need to wrap JQuery object to this element
			});

			or 

			$('div').each(function(index, element) {
				$(element).text(); // No need to wrap JQuery object, element refers to this
			});

>	Appending or removing nodes:
	
		$('<span>(office)</span>').appendTo('.officePhone'); (or)

		$('.officePhone').append('<span>(office)</span>');

		prepend will add it to the begining of the elements

		wrap() - Wrapping elements

		<div class="state">Arizona</div>

		$('.state').wrap('<div class="US_State"/>'); this will results in 

			<div class="US_State">
				<div class="state">Arizona</div>
			</div>

		.remove() is used to remove the nodes.

		addClass(), removeClass(), toggleClass()

>	Handling Events: Identifying event type, event.type -> returns a string
	
		Multiple events and handlers can be defined in on() using a map:

		$('#MyTable tr').on({
			mouseenter: function() {
				$(this).addClass('mouseEnter');
			},
			mouseleave: function() {
				$(this).removeClass('mouseEnter');
			},
			mouseover: function() {
				// Any other action
			}
		});

		hover(moseenter, mouseleave);

		toggle() // toggels through functions defined within

>	Ajax in jQuery
	
		$.get() and $.post() : gets raw data from the server
		$(selector).load() : Loads html data from the sever
		$.getJSON() : get/post and return JSON
		$.ajax() : core functionality

		jQuery ajax functions work with REST API's and web services

		$('#myDiv').load('../sample.html #myID'); // Which loads only #myID content from the sample.html

		$.get(url, data, callback, datatype);
		
		$.get('sample.html', function(data){
			$('#outputDiv').html(data);
		});

------------------------------------------------
* Building a JavaScript Environment: Cory House |
------------------------------------------------

# ember - fully opioniated library

# Editor Selection:
	
	VSCode - JavaScript editor, other options - atom

	EditorConfig - helps create a config for a editor
	
		Install the plugin before using in VS code, goto, editorconfig.org -> download the plugin -> copy the command and open VS code, 'Ctrl + SHift + p' to open the command pallate and paste the command and select to install

		Create .editorconfig file in the project root.

# Package managers:

	Use 'node security platform' to check for package vulnerabilities, install it using,

	$ npm instal --global nsp

	Run this to check, using,

	$ nsp check

# Dev servers:
	
	http-server : Ultra-simple, single command serves current directory
	live-server
	express, koa, hafi
	budo
	webpack-server : hot reloading, serves from memory
	browserSync : dedicated IP for sharing on LAN, all interactions remains in sync, great for cross device testing, integrates with webpack, gulp, browserify

	Consider: express

# Sharing work-in-progress:

	- localtunnel : share in local machine, install using npm, start the app then run using,
		
		usage: $ lt --port 3000

	- ngrok : secure tunnel to local machine, install ngrok, install authtoken, start the app
		
		usage: $ ./ngrok http 80

	  now : install, create the start script, 
		
		usage: $ now

	- surge : Quickly host static files to public URL, install 

		usage: $ surge

	- Consider: localtunnel; usage: $ lt --port 3000

		Add, --subdomain option to include custom subdomain in the url; usage: $ lt -port 3000 --subdomain punith // Will give link as follows, https://punith.localtunnel.me

# Automation:
	
	- grunt

	- gulp : in memory streams, code over configuration, 

	- npm scripts : declared in scripts section of the package.json, can leverage your OS' command line, call separate node scripts, Convention based pre/post hooks, simpler debugging, no need for separate plugins

	- add rules to scripts section in package.json

	- packages used in scripts sections are not required to be installed globally.

		"scripts": {
		    "prestart": "node ./startMessage.js",
		    "start": "node ./index.js",
		    "security-check": "nsp check",
		    "share": "lt --port 3000 --subdomain punith"
	  	},

  - Run user-defined scripts as follows, 

  		$ npm run security-check

  - Running concurrent tasks,

  	"scripts": {
	    "prestart": "node ./startMessage.js",
	    "start": "npm-run-all --parallel security-check open-source",
	    "open-source": "node ./index.js",
	    "security-check": "nsp check",
	    "localtunnel": "lt --port 3000 --subdomain punith",
	    "share": "npm-run-all --parallel open-source localtunnel"
  	},

  - To silence the noise created in the command line, use 

  		$ npm start -s // option to reduce the noise

# Transpilling:

	- TypeScript : Enhanced autocomplete, readability, safer refactoring, additional non-standard features.

	- Elm : compiles down to js, clean syntax, immutable data structures, friendly erros, all errors are compile-time erros, interops with JS -> Deep learing curve required to adopt this

	- Babel : write standardized JS, leverage full JS eco system, use experimental features earlier, no type defs, annotations required, test, lint, great libs, safety, ES6 imports are statically analyzable

		it offers two ways to configure:

		package.json : place it in a section called "babel" : { },

		.babelrc : Recommended - keep it in project root folder, not npm specific
		
		- compile using $ babel-node <file-name.js>

# Bundling:

	- To bundle the JavaScript that the browsers can inderstand

	- webpack - import css, images etc like JS, built-in hot reloading web server, bundle splitting

	- webpack.config.js file in the root folder required.

	- To use it in node.js app, add the following,

		import webpack from 'webpack';
		import config from './webpack.config';

		const compiler = webpack(config);

		// Required to run webpack in express
		app.use(require('webpack-dev-middleware')(compiler, {
		    publicPath: config.output.publicPath
		}));


# Linting:
	
	- Enforces consistency - curly brace position, confirm/alert boxes in production code, trailing commas, declaring global variables, disallowing the usage of eval (potentially risky to use)

	- Avoids mistakes - Extra paranthesis, overwritng a function, assignment in conditional, missing default case in switch, leaving debugger/console.log statements

	- If any of this violated can fail the build while developing and deploying the code in production

	- Linters to consider: JSLint, JS Hint, ES Lint

	- Consider ES Lint - TS Lint supports the type script (consider if working on Type script)
	
	- Can be configured in package.json or create .eslintrc.json file in the project root folder

	- eslintConfig section can be added in package.json

	- @ github.com/dustinspecker/awesome-eslint - to get the available plugins for different JavaScript frameworks

	- Use a preset - ES lint recommended list or start from scrath which fits the team standards or airbnb, standardjs presets

	# Downsides:

		- ESLint doesn't watch files, To watch files use (Upon save)
			
			- eslint-loader (if using webpack) - re-lints all files upon save
			- eslint-watch - ESLint wrapper that adds the file watch - not tied to webpack, better warning/error formatting, displays clean message, easily lint tests and build scripts

		- Doesn't support experimental JavaScript features, to use experimental features use,

			- babel-eslint

	# Need eslint, eslint-watch, eslint-plugin-import plugins to make it work.

	- create a script in package.json as, 

		"lint": "esw webpack.config.* src --color" // esw; eslist-watch executable which looks for config file and in src folder, folders can be specified by leaving a space

		run it as; $ npm run lint

	- To disable a lint in a file, use the following comment in file,

		/* eslint-disable no-console */

	- To disable in lint in a line, use the follwing in the line,

		// eslint-disable-line no-console

	- To watch the files use the following,

		 "lint:watch": "npm run lint -- --watch" -> run it as; $ npm run lint:watch, add the lint:watch to start script of npm

# Testing and Continuous integration:

	- Testing Framework: 

		mocha, jasmine (has assertion library built in), Tape (Minimal configuration), AVA (runs impacted unit tests, new), Jest (from facebook - popular for react developers - wrapper over Jasmine) - Consider -> Mocha

	- Assertion Library: Mocha doesn't have assertion library built

		chai.js, should.js, expect.js - Consider -> chai.js

	- Helper Library: 

		JSDOM - simulate the browser's dom - can run DOM related tests, without a browser
		cheerio - jQuery for the server, Query virtual DOM using jQuery selectors

	- Where to run tests:

		Browser: karma, Testem
		Headless Browsers: PhantomJS - has no visible interface
		In memory DOM: JSDOM - 9.8.0 used in the project

	- mocha + chai + jsdom(9.8.0)
		
		add this in scripts section of package.json

		"test": "mocha --reporter progress src/testSetup.js \"src/**/*.test.js\""

# Continuous integration:
	
	- travis: Linux based
	- appveyor: window based
	- Jenkins
	- circleCI
	- Semaphore
	- snapCI

	- travis

# HTTP Calls:

	- 

	





